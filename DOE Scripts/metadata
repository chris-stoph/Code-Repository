{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "1022b031",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "21e7bba3",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "from tkinter import simpledialog, filedialog\n",
    "import tkinter as tk\n",
    "import os\n",
    "import datetime\n",
    "from pyDOE2 import fullfact\n",
    "\n",
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = factor_levels_df['High'].unique()\n",
    "    low_levels = factor_levels_df['Low'].unique()\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "1daa8742",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "4f12d6e6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = factor_levels_df['High'].unique()\n",
    "    low_levels = factor_levels_df['Low'].unique()\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].values[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "992b2e8f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = factor_levels_df['High'].unique()\n",
    "    low_levels = factor_levels_df['Low'].unique()\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "ab54d36b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "423be77f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = factor_levels_df['High'].unique()\n",
    "    low_levels = factor_levels_df['Low'].unique()\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "1a6ffc49",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'].unique())  # Convert Series to list\n",
    "    low_levels = list(factor_levels_df['Low'].unique())   # Convert Series to list\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "78c1d49c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "134e5d35",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'].unique())  # Convert Series to list\n",
    "    low_levels = list(factor_levels_df['Low'].unique())   # Convert Series to list\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "64dd2509",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "7ff4dd50",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'].unique())  # Convert Series to list\n",
    "    low_levels = list(factor_levels_df['Low'].unique())   # Convert Series to list\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame\n",
    "            full_factorial_df = full_factorial_df.applymap(lambda x: custom_mapping(x, levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "f7da7729",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "172c33a6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'].unique())  # Convert Series to list\n",
    "    low_levels = list(factor_levels_df['Low'].unique())   # Convert Series to list\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "40831e8a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "f3173561",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'].unique())  # Convert Series to list\n",
    "    low_levels = list(factor_levels_df['Low'].unique())   # Convert Series to list\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame column\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "46084087",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "f282125a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'].unique())  # Convert Series to list\n",
    "    low_levels = list(factor_levels_df['Low'].unique())   # Convert Series to list\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, (high, low) in enumerate(zip(high_levels, low_levels)):\n",
    "        mid_level = (high + low) / 2\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels for the specific factor\n",
    "    if value < 1 or value > levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + (value - 1) * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame column\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "11f0b508",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "436d0850",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names, levels, high, and low levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'])\n",
    "    low_levels = list(factor_levels_df['Low'])\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Calculate mid-levels for each factor\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 1 or value > levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + (value - 1) * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame column\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "92f7796c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "62d23d69",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names, levels, high, and low levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'])\n",
    "    low_levels = list(factor_levels_df['Low'])\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Calculate mid-levels for each factor\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 1 or value > levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + (value - 1) * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to values in factor columns\n",
    "        for column in full_factorial_df.columns:\n",
    "            if column in factors:  # Check if the column corresponds to a factor\n",
    "                factor = column\n",
    "                num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "                # Apply custom mapping to each value in the DataFrame column\n",
    "                full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "9de320d9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "a1a3e4fa",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names, levels, high, and low levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'])\n",
    "    low_levels = list(factor_levels_df['Low'])\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Calculate mid-levels for each factor\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 1 or value > levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + (value - 1) * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            if column.startswith('Mid_'):\n",
    "                continue  # Skip mid-level columns\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame column\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "387c3b76",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "91b1fafc",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names, levels, high, and low levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 1 or value > levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + (value - 1) * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            if column.startswith('Mid_'):\n",
    "                continue  # Skip mid-level columns\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame column\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "6e032752",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "f0bd6c03",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, mid_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high, mid, and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - mid_levels (list): List of mid factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(mid_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, mid, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high, mid, and low levels\n",
    "    data = {'Factor': factors, 'Levels': levels, 'High': high_levels, 'Mid': mid_levels, 'Low': low_levels}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - mid_levels (list): List of mid factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    mid_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high, mid, and low levels based on the number of levels\n",
    "        if level == 2:\n",
    "            high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "            low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "            high_levels.append(high_level)\n",
    "            mid_levels.append(None)\n",
    "            low_levels.append(low_level)\n",
    "        else:\n",
    "            high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "            low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "            high_levels.append(high_level)\n",
    "            mid_levels.append((high_level + low_level) / 2)\n",
    "            low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, mid_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, mid_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, mid_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "15868c35",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "9be90a89",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, mid_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high, mid, and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - mid_levels (list): List of mid factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(mid_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, mid, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high, mid, and low levels\n",
    "    data = {'Factor': factors, 'Levels': levels, 'High': high_levels, 'Mid': mid_levels, 'Low': low_levels}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - mid_levels (list): List of mid factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    mid_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high, mid, and low levels based on the number of levels\n",
    "        if level == 2:\n",
    "            high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "            low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "            high_levels.append(high_level)\n",
    "            mid_levels.append(None)\n",
    "            low_levels.append(low_level)\n",
    "        else:\n",
    "            high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "            low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "            high_levels.append(high_level)\n",
    "            mid_levels.append((high_level + low_level) / 2)\n",
    "            low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, mid_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, mid_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, mid_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "de5ff247",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "535537f6",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import os\n",
    "\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High': high_list, 'Mid': mid_list, 'Low': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        # This part remains the same as in your original code\n",
    "        # You can use the provided generate_factor_levels_df function for further processing as needed\n",
    "\n",
    "        # Print factor levels DataFrame\n",
    "        print(\"Factor Levels DataFrame:\")\n",
    "        print(factor_levels_df)\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "e4848301",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "0917ff98",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import os\n",
    "\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High': high_list, 'Mid': mid_list, 'Low': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "9c086684",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "e8143919",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import os\n",
    "\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High': high_list, 'Mid': mid_list, 'Low': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "eea196c1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "90b0504a",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "1a817fe0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "id": "4086784e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "id": "53129867",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "id": "c34146a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = os.path.basename(__file__)\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', notebook_filename)\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "id": "54e58f14",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "id": "ba33ce8b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = os.path.basename(__file__)\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', notebook_filename)\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "id": "d74d234c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "94e687ee",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = os.path.basename(__file__)\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', notebook_filename)\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "id": "c6bd7612",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "id": "af0846bd",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "id": "cc9750f5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "id": "b6168e9b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "cf6afa28",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "462e56e1",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "2523142c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "28044d7a",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "0fd4151d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "id": "7ec23713",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "id": "d7af6ac4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "id": "9296d293",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "\n",
    "    # Add informational columns for notebook filename and date\n",
    "    notebook_filename = os.path.basename(get_ipython().run_line_magic('notebook', 'list').split(':')[1].split('/')[-1].strip())\n",
    "    current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "    df.insert(0, 'Notebook Filename', notebook_filename)\n",
    "    df.insert(1, 'Date', current_date)\n",
    "\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "id": "c5d00fdc",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "id": "2146d069",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "\n",
    "    # Add informational columns for notebook filename and date\n",
    "    notebook_filename = os.path.basename(get_ipython().run_line_magic('notebook', 'list').split(':')[1].split('/')[-1].strip())\n",
    "    current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "    df.insert(0, 'Notebook Filename', notebook_filename)\n",
    "    df.insert(1, 'Date', current_date)\n",
    "\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "id": "1f48b832",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython\n",
    "import ipyparams"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "id": "201a615d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython\n",
    "import ipyparams"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "id": "91ed8841",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import json\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}
