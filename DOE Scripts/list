{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "66db3659",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "ce7ba24e",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "from tkinter import simpledialog, filedialog\n",
    "import tkinter as tk\n",
    "import os\n",
    "import datetime\n",
    "from pyDOE2 import fullfact\n",
    "\n",
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = factor_levels_df['High'].unique()\n",
    "    low_levels = factor_levels_df['Low'].unique()\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "eb24543a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "8ff4878c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = factor_levels_df['High'].unique()\n",
    "    low_levels = factor_levels_df['Low'].unique()\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].values[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "63f79476",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = factor_levels_df['High'].unique()\n",
    "    low_levels = factor_levels_df['Low'].unique()\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "d643dd43",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "ec766b5e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = factor_levels_df['High'].unique()\n",
    "    low_levels = factor_levels_df['Low'].unique()\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "2bb39772",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'].unique())  # Convert Series to list\n",
    "    low_levels = list(factor_levels_df['Low'].unique())   # Convert Series to list\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "25c15125",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "a2a8ea9f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'].unique())  # Convert Series to list\n",
    "    low_levels = list(factor_levels_df['Low'].unique())   # Convert Series to list\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "6b32a0ee",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "ddaedd40",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'].unique())  # Convert Series to list\n",
    "    low_levels = list(factor_levels_df['Low'].unique())   # Convert Series to list\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame\n",
    "            full_factorial_df = full_factorial_df.applymap(lambda x: custom_mapping(x, levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "82042d65",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "c9691c84",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'].unique())  # Convert Series to list\n",
    "    low_levels = list(factor_levels_df['Low'].unique())   # Convert Series to list\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "8a59b443",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "5440f36a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'].unique())  # Convert Series to list\n",
    "    low_levels = list(factor_levels_df['Low'].unique())   # Convert Series to list\n",
    "\n",
    "    # Calculate mid levels\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame column\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "ca119dc4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "88e19951",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'].unique())  # Convert Series to list\n",
    "    low_levels = list(factor_levels_df['Low'].unique())   # Convert Series to list\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, (high, low) in enumerate(zip(high_levels, low_levels)):\n",
    "        mid_level = (high + low) / 2\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels for the specific factor\n",
    "    if value < 1 or value > levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + (value - 1) * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame column\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "8391266f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "5ffee139",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names, levels, high, and low levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'])\n",
    "    low_levels = list(factor_levels_df['Low'])\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Calculate mid-levels for each factor\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 1 or value > levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + (value - 1) * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame column\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "121c34d7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "6a100a2e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names, levels, high, and low levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'])\n",
    "    low_levels = list(factor_levels_df['Low'])\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Calculate mid-levels for each factor\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 1 or value > levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + (value - 1) * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to values in factor columns\n",
    "        for column in full_factorial_df.columns:\n",
    "            if column in factors:  # Check if the column corresponds to a factor\n",
    "                factor = column\n",
    "                num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "                # Apply custom mapping to each value in the DataFrame column\n",
    "                full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "988f237c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "f10904c5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names, levels, high, and low levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    high_levels = list(factor_levels_df['High'])\n",
    "    low_levels = list(factor_levels_df['Low'])\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    # Calculate mid-levels for each factor\n",
    "    mid_levels = [(high + low) / 2 for high, low in zip(high_levels, low_levels)]\n",
    "\n",
    "    # Create mid-level columns\n",
    "    for i, mid_level in enumerate(mid_levels):\n",
    "        df[f'Mid_{i+1}'] = mid_level\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 1 or value > levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + (value - 1) * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            if column.startswith('Mid_'):\n",
    "                continue  # Skip mid-level columns\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame column\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "ba468c97",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "9202eff4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold columns data\n",
    "    factor_data = []\n",
    "    level_data = []\n",
    "    high_data = []\n",
    "    low_data = []\n",
    "\n",
    "    # Iterate through each factor and its levels\n",
    "    for i, factor in enumerate(factors):\n",
    "        factor_data.extend([factor] * levels[i])\n",
    "        level_data.extend(list(range(1, levels[i] + 1)))\n",
    "        high_data.extend([high_levels[i]] * levels[i])\n",
    "        low_data.extend([low_levels[i]] * levels[i])\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high and low levels\n",
    "    data = {'Factor': factor_data, 'Levels': level_data, 'High': high_data, 'Low': low_data}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names, levels, high, and low levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "\n",
    "    return df\n",
    "\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 1 or value > levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + (value - 1) * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels based on the number of levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Check if the number of factors matches the number of levels, high levels, and low levels\n",
    "    if len(factors) != len(levels) or len(factors) != len(high_levels) or len(factors) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high levels, and low levels must be the same.\")\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            if column.startswith('Mid_'):\n",
    "                continue  # Skip mid-level columns\n",
    "            factor = column\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == factor, 'Levels'].values[0]\n",
    "            # Apply custom mapping to each value in the DataFrame column\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "d7f9334c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "d94ecb2b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, mid_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high, mid, and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - mid_levels (list): List of mid factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(mid_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, mid, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high, mid, and low levels\n",
    "    data = {'Factor': factors, 'Levels': levels, 'High': high_levels, 'Mid': mid_levels, 'Low': low_levels}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - mid_levels (list): List of mid factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    mid_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high, mid, and low levels based on the number of levels\n",
    "        if level == 2:\n",
    "            high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "            low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "            high_levels.append(high_level)\n",
    "            mid_levels.append(None)\n",
    "            low_levels.append(low_level)\n",
    "        else:\n",
    "            high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "            low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "            high_levels.append(high_level)\n",
    "            mid_levels.append((high_level + low_level) / 2)\n",
    "            low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, mid_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, mid_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, mid_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "2396c0d8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "4769c1b4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to generate factor levels DataFrame\n",
    "def generate_factor_levels_df(factors, levels, high_levels, mid_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high, mid, and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - mid_levels (list): List of mid factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(mid_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, mid, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, and high, mid, and low levels\n",
    "    data = {'Factor': factors, 'Levels': levels, 'High': high_levels, 'Mid': mid_levels, 'Low': low_levels}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - mid_levels (list): List of mid factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    mid_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, mid levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high, mid, and low levels based on the number of levels\n",
    "        if level == 2:\n",
    "            high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "            low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "            high_levels.append(high_level)\n",
    "            mid_levels.append(None)\n",
    "            low_levels.append(low_level)\n",
    "        else:\n",
    "            high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "            low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "            high_levels.append(high_level)\n",
    "            mid_levels.append((high_level + low_level) / 2)\n",
    "            low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, mid_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, mid_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, mid_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "c93bddc0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "44195cd1",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import os\n",
    "\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High': high_list, 'Mid': mid_list, 'Low': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        # This part remains the same as in your original code\n",
    "        # You can use the provided generate_factor_levels_df function for further processing as needed\n",
    "\n",
    "        # Print factor levels DataFrame\n",
    "        print(\"Factor Levels DataFrame:\")\n",
    "        print(factor_levels_df)\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "22a7a99d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "841270ca",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import os\n",
    "\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High': high_list, 'Mid': mid_list, 'Low': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "379f08cf",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "b69c81f9",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import os\n",
    "\n",
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High': high_list, 'Mid': mid_list, 'Low': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "a3d56d3a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "f4b91b2b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "c12caf2f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "id": "feb54fb9",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "id": "e67266ee",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "id": "507fa3bf",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = os.path.basename(__file__)\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', notebook_filename)\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "id": "8f5d3fe8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "id": "11dbee3c",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = os.path.basename(__file__)\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', notebook_filename)\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "id": "cfbeb6d2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "61635590",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = os.path.basename(__file__)\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', notebook_filename)\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "id": "9504800d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "id": "f39df389",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "id": "062acd99",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "id": "bf195968",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "49f7c899",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "8d13edf0",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "4e957a86",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "c68ec5cf",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "f5bd4cfb",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "id": "e3cae548",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "id": "d1574b6e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "id": "07482657",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_factor_levels_df(factors, levels, high_levels, low_levels):\n",
    "    \"\"\"\n",
    "    Generate a DataFrame with factor names, number of levels, and high and low levels.\n",
    "\n",
    "    Args:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List containing the number of levels for each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing factor names, levels, high, mid, and low levels.\n",
    "    \"\"\"\n",
    "    # Check if the number of factors matches the number of levels\n",
    "    if len(factors) != len(levels) != len(high_levels) != len(low_levels):\n",
    "        raise ValueError(\"Number of factors, levels, high, and low levels must be the same.\")\n",
    "    # Check if all levels are positive integers\n",
    "    if not all(isinstance(level, int) and level > 0 for level in levels):\n",
    "        raise ValueError(\"Levels must be positive integers.\")\n",
    "\n",
    "    # Create lists to hold factor names, levels, high, mid, and low levels\n",
    "    factor_list = []\n",
    "    level_list = []\n",
    "    high_list = []\n",
    "    mid_list = []\n",
    "    low_list = []\n",
    "\n",
    "    # Iterate through factors and calculate mid levels if levels > 2\n",
    "    for factor, num_levels, high_level, low_level in zip(factors, levels, high_levels, low_levels):\n",
    "        factor_list.append(factor)\n",
    "        level_list.append(num_levels)\n",
    "        high_list.append(high_level)\n",
    "        low_list.append(low_level)\n",
    "\n",
    "        # Calculate mid levels\n",
    "        if num_levels > 2:\n",
    "            mid = [(low_level + ((high_level - low_level) * i) / (num_levels - 1)) for i in range(1, num_levels - 1)]\n",
    "            # Round mid levels to two decimal places\n",
    "            mid = sorted([round(m, 2) for m in mid])\n",
    "            mid_list.append(mid)\n",
    "        else:\n",
    "            mid_list.append(None)\n",
    "\n",
    "    # Create a dictionary to hold factor names, levels, high, mid, and low levels\n",
    "    data = {'Factor': factor_list, 'Levels': level_list, 'High (+1)': high_list, 'Mid (0, +/-0.333, +/-0.5, etc)': mid_list, 'Low (-1)': low_list}\n",
    "    # Convert the dictionary into a DataFrame\n",
    "    df = pd.DataFrame(data)\n",
    "\n",
    "    # Add informational columns for notebook filename and date\n",
    "    notebook_filename = os.path.basename(get_ipython().run_line_magic('notebook', 'list').split(':')[1].split('/')[-1].strip())\n",
    "    current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "    df.insert(0, 'Notebook Filename', notebook_filename)\n",
    "    df.insert(1, 'Date', current_date)\n",
    "\n",
    "    return df\n",
    "\n",
    "# Function to create full factorial design DataFrame\n",
    "def create_full_factorial_design(factor_levels_df):\n",
    "    \"\"\"\n",
    "    Generate a full factorial design DataFrame based on specified factors and levels.\n",
    "\n",
    "    Args:\n",
    "    - factor_levels_df (DataFrame): DataFrame containing factor names, levels, high, mid, and low levels.\n",
    "\n",
    "    Returns:\n",
    "    - df (DataFrame): DataFrame representing the full factorial design.\n",
    "    \"\"\"\n",
    "    # Extract factor names and levels from the DataFrame\n",
    "    factors = factor_levels_df['Factor'].tolist()\n",
    "    levels = factor_levels_df['Levels'].tolist()\n",
    "    # Generate the full factorial design using pyDOE2's fullfact() function\n",
    "    design = fullfact(levels)\n",
    "    # Convert the design into a DataFrame with appropriate column names\n",
    "    df = pd.DataFrame(design, columns=factors)\n",
    "    return df\n",
    "\n",
    "# Define the custom mapping function\n",
    "def custom_mapping(value, levels):\n",
    "    \"\"\"\n",
    "    Custom mapping function to transform values according to specific rules.\n",
    "\n",
    "    Args:\n",
    "    - value (int): Value representing factor level.\n",
    "    - levels (int): Number of levels for the factor.\n",
    "\n",
    "    Returns:\n",
    "    - mapped_value (float): Transformed value.\n",
    "    \"\"\"\n",
    "    # Check if the value is within the valid range of levels\n",
    "    if value < 0 or value >= levels:\n",
    "        return value  # Value outside the defined levels, return as is\n",
    "\n",
    "    # Calculate the spacing between each level\n",
    "    spacing = 2 / (levels - 1)\n",
    "\n",
    "    # Map the value to the corresponding value in the range [-1, 1]\n",
    "    mapped_value = -1 + value * spacing\n",
    "\n",
    "    return mapped_value\n",
    "\n",
    "def get_user_input():\n",
    "    \"\"\"\n",
    "    Prompt the user to input factors, levels, number of replicates, Excel file name, and export folder.\n",
    "    Additionally, prompt for high, mid, and low factor levels for each factor based on the number of levels.\n",
    "\n",
    "    Returns:\n",
    "    - factors (list): List of factor names.\n",
    "    - levels (list): List of levels corresponding to each factor.\n",
    "    - high_levels (list): List of high factor levels for each factor.\n",
    "    - low_levels (list): List of low factor levels for each factor.\n",
    "    - num_replicates (int): Number of replicates.\n",
    "    - excel_file_name (str): Excel file name.\n",
    "    - export_folder (str): Export folder path.\n",
    "    \"\"\"\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()  # Hide the root window\n",
    "\n",
    "    # Prompt user for the number of factors\n",
    "    num_factors = simpledialog.askinteger(\"Input\", \"Enter the number of factors:\")\n",
    "\n",
    "    factors = []\n",
    "    levels = []\n",
    "    high_levels = []\n",
    "    low_levels = []\n",
    "\n",
    "    # Prompt user to enter factor names, levels, high levels, and low levels\n",
    "    for i in range(num_factors):\n",
    "        factor = simpledialog.askstring(\"Input\", f\"Enter the name of factor {i+1}:\")\n",
    "        factors.append(factor)\n",
    "\n",
    "        level = simpledialog.askinteger(\"Input\", f\"Enter the number of levels for factor {factor}:\")\n",
    "        levels.append(level)\n",
    "\n",
    "        # Calculate high and low levels\n",
    "        high_level = simpledialog.askinteger(\"Input\", f\"Enter the high level for factor {factor}:\")\n",
    "        low_level = simpledialog.askinteger(\"Input\", f\"Enter the low level for factor {factor}:\")\n",
    "        high_levels.append(high_level)\n",
    "        low_levels.append(low_level)\n",
    "\n",
    "    # Prompt user to enter the number of replicates\n",
    "    num_replicates = simpledialog.askinteger(\"Input\", \"Enter the number of replicates:\")\n",
    "\n",
    "    # Prompt user to enter the Excel file name\n",
    "    excel_file_name = simpledialog.askstring(\"Input\", \"Enter the Excel file name:\")\n",
    "\n",
    "    # Prompt user to select the export folder\n",
    "    export_folder = filedialog.askdirectory(title=\"Select Export Folder\")\n",
    "\n",
    "    return factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder\n",
    "\n",
    "def main():\n",
    "    try:\n",
    "        # Get user input\n",
    "        factors, levels, high_levels, low_levels, num_replicates, excel_file_name, export_folder = get_user_input()\n",
    "\n",
    "        # Generate factor levels DataFrame\n",
    "        factor_levels_df = generate_factor_levels_df(factors, levels, high_levels, low_levels)\n",
    "\n",
    "        # Create full factorial design DataFrame\n",
    "        full_factorial_df = create_full_factorial_design(factor_levels_df)\n",
    "\n",
    "        # Apply custom mapping to each value in the DataFrame\n",
    "        for column in full_factorial_df.columns:\n",
    "            num_levels = factor_levels_df.loc[factor_levels_df['Factor'] == column, 'Levels'].iloc[0]\n",
    "            full_factorial_df[column] = full_factorial_df[column].apply(lambda x: custom_mapping(x, num_levels))\n",
    "\n",
    "        # Duplicate the full factorial design DataFrame\n",
    "        full_factorial_df_duplicated = pd.concat([full_factorial_df] * num_replicates, ignore_index=True)\n",
    "\n",
    "        # Merge the two DataFrames\n",
    "        merged_df = pd.concat([factor_levels_df, pd.DataFrame(columns=['']), full_factorial_df_duplicated], axis=1)\n",
    "\n",
    "        # Add informational columns to the left\n",
    "        # Get the filename of the IPython Notebook being executed\n",
    "        notebook_filename = get_ipython().get_parent().get_metadata()['path']\n",
    "\n",
    "        # Get the current date\n",
    "        current_date = datetime.datetime.now().strftime('%Y-%m-%d')\n",
    "\n",
    "        # Insert the informational columns\n",
    "        merged_df.insert(0, 'Notebook Filename', os.path.basename(notebook_filename))\n",
    "        merged_df.insert(1, 'Date', current_date)\n",
    "\n",
    "        # Add a blank column with heading 'Results' after the last factor\n",
    "        merged_df.insert(len(merged_df.columns), 'Results', '')\n",
    "\n",
    "        # Append '.xlsx' extension if not provided\n",
    "        if not excel_file_name.endswith('.xlsx'):\n",
    "            excel_file_name += '.xlsx'\n",
    "\n",
    "        # Write the merged DataFrame to an Excel file in the export folder\n",
    "        excel_file_path = os.path.join(export_folder, excel_file_name)\n",
    "        merged_df.to_excel(excel_file_path, index=False)\n",
    "        print(\"Excel file saved successfully.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(\"An error occurred:\", e)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "id": "4d20153e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import tkinter as tk\n",
    "from tkinter import simpledialog, filedialog\n",
    "import pandas as pd\n",
    "from pyDOE2 import fullfact\n",
    "import os\n",
    "import datetime\n",
    "import sys\n",
    "from IPython import get_ipython"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}
